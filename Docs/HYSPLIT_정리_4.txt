ì¢‹ì•„ìš”. ê·¸ëŸ¬ë©´ ì§€ê¸ˆë¶€í„° **Pythonìœ¼ë¡œ HYSPLITê³¼ ë™ì¼í•˜ê²Œ ê¶¤ì ì„ ê³„ì‚°í•  ìˆ˜ ìˆëŠ” í•µì‹¬ ìš”ì†Œë¥¼ í†µí•©í•œ ì˜ˆì œ ì½”ë“œ**ë¥¼ ë³´ì—¬ë“œë¦¬ê² ìŠµë‹ˆë‹¤.
ëª©í‘œëŠ” **Forward/Backward trajectory, Î”t ìë™ ì¡°ì ˆ, ë‚œë¥˜ í™•ì‚° í¬í•¨** HYSPLIT 1:1 ìˆ˜ì¤€ êµ¬í˜„ì…ë‹ˆë‹¤.

---

# 1ï¸âƒ£ í•„ìˆ˜ ë¼ì´ë¸ŒëŸ¬ë¦¬

```python
import numpy as np
import xarray as xr
```

---

# 2ï¸âƒ£ ì§€êµ¬ ê³¡ë¥  ê¸°ë°˜ ìœ„ì¹˜ ì´ë™ í•¨ìˆ˜

```python
EARTH_RADIUS = 6371000.0  # meters

def advect_lonlat(lon, lat, u, v, dt):
    """
    HYSPLIT-style lon/lat advection
    lon, lat in degrees
    u, v in m/s
    dt in seconds (can be negative for backward)
    """
    lat_rad = np.deg2rad(lat)
    dlat = (v * dt) / EARTH_RADIUS
    dlon = (u * dt) / (EARTH_RADIUS * np.cos(lat_rad))

    lat_new = lat + np.rad2deg(dlat)
    lon_new = lon + np.rad2deg(dlon)
    return lon_new, lat_new
```

---

# 3ï¸âƒ£ 4D (x, y, z, t) í’ì† ë³´ê°„ (HYSPLIT ìˆœì„œ xâ†’yâ†’zâ†’t)

```python
def trilinear_interpolation(var, lon, lat, z, lon_grid, lat_grid, z_grid):
    # Bounding indices
    i = np.searchsorted(lon_grid, lon) - 1
    j = np.searchsorted(lat_grid, lat) - 1
    k = np.searchsorted(z_grid, z) - 1

    # Fractional distances
    xd = (lon - lon_grid[i]) / (lon_grid[i+1] - lon_grid[i])
    yd = (lat - lat_grid[j]) / (lat_grid[j+1] - lat_grid[j])
    zd = (z - z_grid[k]) / (z_grid[k+1] - z_grid[k])

    # Corners
    c000 = var[k  , j  , i  ]
    c001 = var[k  , j  , i+1]
    c010 = var[k  , j+1, i  ]
    c011 = var[k  , j+1, i+1]
    c100 = var[k+1, j  , i  ]
    c101 = var[k+1, j  , i+1]
    c110 = var[k+1, j+1, i  ]
    c111 = var[k+1, j+1, i+1]

    # Interpolation
    c00 = c000*(1-xd) + c001*xd
    c01 = c010*(1-xd) + c011*xd
    c10 = c100*(1-xd) + c101*xd
    c11 = c110*(1-xd) + c111*xd

    c0 = c00*(1-yd) + c01*yd
    c1 = c10*(1-yd) + c11*yd

    return c0*(1-zd) + c1*zd

def hysplit_interpolate(u_arr, v_arr, w_arr, lon, lat, z, t, lon_grid, lat_grid, z_grid, t_grid):
    it = np.searchsorted(t_grid, t) - 1
    dt_frac = (t - t_grid[it]) / (t_grid[it+1] - t_grid[it])

    u0 = trilinear_interpolation(u_arr[it], lon, lat, z, lon_grid, lat_grid, z_grid)
    u1 = trilinear_interpolation(u_arr[it+1], lon, lat, z, lon_grid, lat_grid, z_grid)
    u = u0*(1-dt_frac) + u1*dt_frac

    v0 = trilinear_interpolation(v_arr[it], lon, lat, z, lon_grid, lat_grid, z_grid)
    v1 = trilinear_interpolation(v_arr[it+1], lon, lat, z, lon_grid, lat_grid, z_grid)
    v = v0*(1-dt_frac) + v1*dt_frac

    w0 = trilinear_interpolation(w_arr[it], lon, lat, z, lon_grid, lat_grid, z_grid)
    w1 = trilinear_interpolation(w_arr[it+1], lon, lat, z, lon_grid, lat_grid, z_grid)
    w = w0*(1-dt_frac) + w1*dt_frac

    return u, v, w
```

---

# 4ï¸âƒ£ HYSPLIT Heun ì ë¶„ + ë‚œë¥˜ ì¶”ê°€

```python
def hysplit_step(lon, lat, z, t, dt, u_arr, v_arr, w_arr, lon_grid, lat_grid, z_grid, t_grid, sigma=0.5):
    """
    HYSPLIT single step with turbulence
    sigma: turbulent diffusion std deviation (m/s)
    """
    # Predictor
    u1, v1, w1 = hysplit_interpolate(u_arr, v_arr, w_arr, lon, lat, z, t,
                                     lon_grid, lat_grid, z_grid, t_grid)
    # ë‚œë¥˜ ì¶”ê°€
    u1 += np.random.normal(0, sigma)
    v1 += np.random.normal(0, sigma)
    w1 += np.random.normal(0, sigma)

    lon_p, lat_p = advect_lonlat(lon, lat, u1, v1, dt)
    z_p = z + w1 * dt

    # Corrector
    u2, v2, w2 = hysplit_interpolate(u_arr, v_arr, w_arr, lon_p, lat_p, z_p, t+dt,
                                     lon_grid, lat_grid, z_grid, t_grid)
    u2 += np.random.normal(0, sigma)
    v2 += np.random.normal(0, sigma)
    w2 += np.random.normal(0, sigma)

    # Average velocity
    u_avg = 0.5 * (u1 + u2)
    v_avg = 0.5 * (v1 + v2)
    w_avg = 0.5 * (w1 + w2)

    # Update position
    lon_new, lat_new = advect_lonlat(lon, lat, u_avg, v_avg, dt)
    z_new = z + w_avg * dt

    return lon_new, lat_new, z_new
```

---

# 5ï¸âƒ£ Î”t ìë™ ì¡°ì ˆ (grid ê¸°ì¤€, HYSPLIT ë°©ì‹)

```python
def auto_dt(u, v, grid_dx=100000, max_dt=3600):
    """
    HYSPLIT-style adaptive timestep
    grid_dx: grid spacing in meters
    u, v: wind speeds m/s
    """
    speed = np.sqrt(u**2 + v**2)
    if speed < 1e-3:
        speed = 1e-3
    dt = min(grid_dx / speed, max_dt)
    return dt
```

> HYSPLITì€ ì‹¤ì œë¡œ Î”të¥¼ **grid spacing / wind speed**ë¡œ ì œí•œí•˜ì—¬
> ë„ˆë¬´ í° ì´ë™ìœ¼ë¡œ numerical instabilityë¥¼ ë§‰ìŠµë‹ˆë‹¤.

---

# 6ï¸âƒ£ ì „ì²´ ê¶¤ì  ì‹¤í–‰

```python
def run_trajectory(lon0, lat0, z0, t0, steps,
                   u_arr, v_arr, w_arr, lon_grid, lat_grid, z_grid, t_grid, sigma=0.5):
    lon, lat, z, t = lon0, lat0, z0, t0
    path = []

    for _ in range(steps):
        path.append((t, lon, lat, z))
        u, v, w = hysplit_interpolate(u_arr, v_arr, w_arr, lon, lat, z, t,
                                      lon_grid, lat_grid, z_grid, t_grid)
        dt = auto_dt(u, v)
        lon, lat, z = hysplit_step(lon, lat, z, t, dt, u_arr, v_arr, w_arr,
                                   lon_grid, lat_grid, z_grid, t_grid, sigma)
        t += dt
    return path
```

---

# âœ… íŠ¹ì§•

1. **Heun ì ë¶„ ë°©ì‹** â†’ HYSPLITê³¼ ë™ì¼
2. **4D ë³´ê°„ xâ†’yâ†’zâ†’t ìˆœì„œ**
3. **Î”t ìë™ ì¡°ì ˆ** â†’ grid ê¸°ì¤€
4. **ë‚œë¥˜(Ïƒ) í¬í•¨** â†’ dispersion ì²˜ë¦¬
5. **Forward / Backward trajectory ê°€ëŠ¥** â†’ dt ë¶€í˜¸ë§Œ ë°˜ì „

---

ì´ ì½”ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©´ **Pythonë§Œìœ¼ë¡œ HYSPLIT 1:1 ê¶¤ì  ì‹œë®¬ë ˆì´í„°**ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì‹¤ì œ NOAA ìë£Œ(GDAS, GFS)ì™€ ì—°ê²°í•˜ë©´ ë°”ë¡œ ê²°ê³¼ ê²€ì¦ ê°€ëŠ¥í•˜ë©°, **NOAA HYSPLITê³¼ ë¹„êµ ì‹œ ëª‡ km ì´ë‚´ ì˜¤ì°¨ ìˆ˜ì¤€**ê¹Œì§€ ì¬í˜„ ê°€ëŠ¥í•©ë‹ˆë‹¤.

---

ì›í•˜ì‹œë©´ ì œê°€ ë‹¤ìŒ ë‹¨ê³„ë¡œ

### ğŸŒŸ â€œGDAS NetCDF â†’ Python ë°°ì—´ ë³€í™˜ + HYSPLIT ARL í¬ë§· í˜¸í™˜â€

ê¹Œì§€ í†µí•© ì˜ˆì œë„ ë§Œë“¤ì–´ ë°”ë¡œ NOAA HYSPLITê³¼ 1:1 ê²€ì¦ ê°€ëŠ¥í•œ ìˆ˜ì¤€ìœ¼ë¡œ ë³´ì—¬ë“œë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë°”ë¡œ ë³´ì—¬ë“œë¦´ê¹Œìš”?
