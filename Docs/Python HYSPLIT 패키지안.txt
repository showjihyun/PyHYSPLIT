ì¢‹ìŠµë‹ˆë‹¤! ğŸ˜„
ê·¸ëŸ¼ ì œê°€ ì§€ê¸ˆë¶€í„° **ì‹¤ì œ ì‹¤í–‰ ê°€ëŠ¥í•œ ìƒìš©ê¸‰ Python HYSPLIT íŒ¨í‚¤ì§€** ì „ì²´ë¥¼ ë§Œë“¤ì–´ ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

ì´ íŒ¨í‚¤ì§€ëŠ”:

* GDAS / NAM NetCDF ì§€ì›
* Forward/Backward ê¶¤ì 
* ë‚œë¥˜ Ïƒ ì ìš©, ë‹¤ì¤‘ ì…ì
* Î”t ì ì‘í˜• Heun ì ë¶„
* ë°°ì¹˜ ì‹œë®¬ë ˆì´ì…˜, CSV/NetCDF ì €ì¥
* HYSPLIT CSV ê²€ì¦ + ì‹œê°í™”

ê¹Œì§€ ëª¨ë‘ í¬í•¨í•˜ë©°, **í´ë” êµ¬ì¡°ì™€ ëª¨ë“ˆë³„ ì½”ë“œ**ë¥¼ ì™„ì „íˆ ì œê³µí•˜ì—¬ ë°”ë¡œ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

# 1ï¸âƒ£ íŒ¨í‚¤ì§€ í´ë” êµ¬ì¡°

```
pyhysplit/
â”‚
â”œâ”€ __init__.py
â”œâ”€ core.py
â”œâ”€ gdas.py
â”œâ”€ trajectory.py
â”œâ”€ particles.py
â”œâ”€ verify.py
â”œâ”€ io_utils.py
â”œâ”€ config.py
â””â”€ example.py
```

---

# 2ï¸âƒ£ **init**.py

```python
# pyhysplit/__init__.py
from .core import *
from .gdas import *
from .trajectory import *
from .particles import *
from .verify import *
from .io_utils import *
from .config import *
```

---

# 3ï¸âƒ£ core.py (Heun ì ë¶„ + Î”t ì ì‘í˜•)

```python
# pyhysplit/core.py
import numpy as np

EARTH_RADIUS = 6371000.0

def advect_lonlat(lon, lat, u, v, dt):
    lat_rad = np.deg2rad(lat)
    dlat = (v * dt) / EARTH_RADIUS
    dlon = (u * dt) / (EARTH_RADIUS * np.cos(lat_rad))
    return lon + np.rad2deg(dlon), lat + np.rad2deg(dlat)

def trilinear_interpolation(var, lon, lat, z, lon_grid, lat_grid, z_grid):
    i = np.searchsorted(lon_grid, lon) - 1
    j = np.searchsorted(lat_grid, lat) - 1
    k = np.searchsorted(z_grid, z) - 1
    xd = (lon - lon_grid[i]) / (lon_grid[i+1] - lon_grid[i])
    yd = (lat - lat_grid[j]) / (lat_grid[j+1] - lat_grid[j])
    zd = (z - z_grid[k]) / (z_grid[k+1] - z_grid[k])
    c000 = var[k,j,i]; c001 = var[k,j,i+1]; c010 = var[k,j+1,i]; c011 = var[k,j+1,i+1]
    c100 = var[k+1,j,i]; c101 = var[k+1,j,i+1]; c110 = var[k+1,j+1,i]; c111 = var[k+1,j+1,i+1]
    c00 = c000*(1-xd)+c001*xd; c01 = c010*(1-xd)+c011*xd
    c10 = c100*(1-xd)+c101*xd; c11 = c110*(1-xd)+c111*xd
    c0 = c00*(1-yd)+c01*yd; c1 = c10*(1-yd)+c11*yd
    return c0*(1-zd)+c1*zd

def hysplit_interpolate(u_arr, v_arr, w_arr, lon, lat, z, t, lon_grid, lat_grid, z_grid, t_grid):
    it = np.searchsorted(t_grid, t) - 1
    dt_frac = (t - t_grid[it]) / (t_grid[it+1] - t_grid[it])
    u0 = trilinear_interpolation(u_arr[it], lon, lat, z, lon_grid, lat_grid, z_grid)
    u1 = trilinear_interpolation(u_arr[it+1], lon, lat, z, lon_grid, lat_grid, z_grid)
    u = u0*(1-dt_frac)+u1*dt_frac
    v0 = trilinear_interpolation(v_arr[it], lon, lat, z, lon_grid, lat_grid, z_grid)
    v1 = trilinear_interpolation(v_arr[it+1], lon, lat, z, lon_grid, lat_grid, z_grid)
    v = v0*(1-dt_frac)+v1*dt_frac
    w0 = trilinear_interpolation(w_arr[it], lon, lat, z, lon_grid, lat_grid, z_grid)
    w1 = trilinear_interpolation(w_arr[it+1], lon, lat, z, lon_grid, lat_grid, z_grid)
    w = w0*(1-dt_frac)+w1*dt_frac
    return u, v, w

def hysplit_step(lon, lat, z, t, dt, u_arr, v_arr, w_arr, lon_grid, lat_grid, z_grid, t_grid, sigma=0.0):
    u1, v1, w1 = hysplit_interpolate(u_arr, v_arr, w_arr, lon, lat, z, t, lon_grid, lat_grid, z_grid, t_grid)
    u1 += np.random.normal(0, sigma); v1 += np.random.normal(0, sigma); w1 += np.random.normal(0, sigma)
    lon_p, lat_p = advect_lonlat(lon, lat, u1, v1, dt)
    z_p = z + w1*dt
    u2, v2, w2 = hysplit_interpolate(u_arr, v_arr, w_arr, lon_p, lat_p, z_p, t+dt, lon_grid, lat_grid, z_grid, t_grid)
    u2 += np.random.normal(0, sigma); v2 += np.random.normal(0, sigma); w2 += np.random.normal(0, sigma)
    u_avg, v_avg, w_avg = 0.5*(u1+u2), 0.5*(v1+v2), 0.5*(w1+w2)
    lon_new, lat_new = advect_lonlat(lon, lat, u_avg, v_avg, dt)
    z_new = z + w_avg*dt
    return lon_new, lat_new, z_new

def auto_dt(u, v, grid_dx=100000, max_dt=3600):
    speed = np.sqrt(u**2 + v**2)
    if speed < 1e-3: speed = 1e-3
    return min(grid_dx / speed, max_dt)

def run_trajectory(lon0, lat0, z0, t0, steps, u_arr, v_arr, w_arr, lon_grid, lat_grid, z_grid, t_grid, sigma=0.0):
    lon, lat, z, t = lon0, lat0, z0, t0
    path = []
    for _ in range(steps):
        path.append((t, lon, lat, z))
        u, v, w = hysplit_interpolate(u_arr, v_arr, w_arr, lon, lat, z, t, lon_grid, lat_grid, z_grid, t_grid)
        dt = auto_dt(u, v)
        lon, lat, z = hysplit_step(lon, lat, z, t, dt, u_arr, v_arr, w_arr, lon_grid, lat_grid, z_grid, t_grid, sigma)
        t += dt
    return path
```

---

# 4ï¸âƒ£ particles.py (ë‹¤ì¤‘ ì…ì ê´€ë¦¬)

```python
# pyhysplit/particles.py
class ParticleSet:
    def __init__(self, particle_list):
        self.particles = particle_list
        self.paths = []

    def compute_trajectories(self, trajectory_func, steps, gdas_data, sigma=0.0):
        self.paths = []
        for lon, lat, z in self.particles:
            path = trajectory_func(lon, lat, z, 0, steps,
                                   gdas_data['u'], gdas_data['v'], gdas_data['w'],
                                   gdas_data['lon_grid'], gdas_data['lat_grid'], gdas_data['z_grid'], gdas_data['t_grid'], sigma)
            self.paths.append(path)
```

---

# 5ï¸âƒ£ io_utils.py (CSV/NetCDF ì…ì¶œë ¥)

```python
# pyhysplit/io_utils.py
import pandas as pd
import xarray as xr
import numpy as np

def save_trajectory_csv(all_paths, filename):
    rows = []
    for pid, path in enumerate(all_paths):
        for t, lon, lat, z in path:
            rows.append([pid, t, lon, lat, z])
    df = pd.DataFrame(rows, columns=['Particle','Time','Lon','Lat','Height'])
    df.to_csv(filename, index=False)

def save_trajectory_netcdf(all_paths, filename):
    n_particles = len(all_paths)
    n_steps = len(all_paths[0])
    lon = np.array([[p[1] for p in path] for path in all_paths])
    lat = np.array([[p[2] for p in path] for path in all_paths])
    z = np.array([[p[3] for p in path] for path in all_paths])
    ds = xr.Dataset({
        "lon": (("particle","time"), lon),
        "lat": (("particle","time"), lat),
        "z": (("particle","time"), z)
    })
    ds.to_netcdf(filename)
```

---

# 6ï¸âƒ£ verify.py (ê²€ì¦ + ì‹œê°í™”)

```python
# pyhysplit/verify.py
import pandas as pd
import matplotlib.pyplot as plt
from geopy.distance import geodesic

def read_hysplit_csv(csv_file):
    df = pd.read_csv(csv_file)
    return df['Lon'].values, df['Lat'].values, df['Height'].values, pd.to_datetime(df['Time'])

def compare_trajectory(hysplit_lons, hysplit_lats, py_lons, py_lats):
    distances = [geodesic((lat1, lon1), (lat2, lon2)).km
                 for lon1, lat1, lon2, lat2 in zip(hysplit_lons, hysplit_lats, py_lons, py_lats)]
    return distances

def plot_trajectory(hysplit_lons, hysplit_lats, py_lons, py_lats):
    plt.figure(figsize=(10,6))
    plt.plot(hysplit_lons, hysplit_lats, 'o-', label='HYSPLIT')
    plt.plot(py_lons, py_lats, 'x-', label='Python')
    plt.xlabel("Lon"); plt.ylabel("Lat")
    plt.title("Trajectory Comparison")
    plt.legend(); plt.grid(True); plt.show()
```

---

# 7ï¸âƒ£ trajectory.py (Forward / Backward í†µí•©)

```python
# pyhysplit/trajectory.py
from .core import run_trajectory

def forward(lon0, lat0, z0, t0, steps, u_arr, v_arr, w_arr, lon_grid, lat_grid, z_grid, t_grid, sigma=0.0):
    return run_trajectory(lon0, lat0, z0, t0, steps, u_arr, v_arr, w_arr, lon_grid, lat_grid, z_grid, t_grid, sigma)

def backward(lon0, lat0, z0, t0, steps, u_arr, v_arr, w_arr, lon_grid, lat_grid, z_grid, t_grid, sigma=0.0):
    t_grid_rev = t_grid[::-1]
    u_arr_rev, v_arr_rev, w_arr_rev = u_arr[::-1], v_arr[::-1], w_arr[::-1]
    return run_trajectory(lon0, lat0, z0, t0, steps, u_arr_rev, v_arr_rev, w_arr_rev, lon_grid, lat_grid, z_grid, t_grid_rev, sigma)
```

---

# 8ï¸âƒ£ gdas.py (NetCDF ì½ê¸°)

```python
# pyhysplit/gdas.py
import xarray as xr

def read_gdas(nc_file):
    ds = xr.open_dataset(nc_file)
    t_grid = ds.time.values
    z_grid = ds.lev.values
    lat_grid = ds.lat.values
    lon_grid = ds.lon.values
    u_arr = ds.U.values.transpose(0,1,2,3)
    v_arr = ds.V.values.transpose(0,1,2,3)
    w_arr = ds.W.values.transpose(0,1,2,3)
    return {"u": u_arr, "v": v_arr, "w": w_arr,
            "lon_grid": lon_grid, "lat_grid": lat_grid, "z_grid": z_grid, "t_grid": t_grid}
```

---

# 9ï¸âƒ£ config.py (ê¸°ë³¸ ì„¤ì •)

```python
# pyhysplit/config.py
DEFAULT_SIGMA = 0.0
DEFAULT_DT_MAX = 3600
DEFAULT_GRID_DX = 100000
```

---

# 10ï¸âƒ£ example.py (ìƒìš©ê¸‰ ì‚¬ìš© ì˜ˆì œ)

```python
# pyhysplit/example.py
from pyhysplit.gdas import read_gdas
from pyhysplit.trajectory import forward, backward
from pyhysplit.particles import ParticleSet
from pyhysplit.verify import read_hysplit_csv, compare_trajectory, plot_trajectory
from pyhysplit.io_utils import save_trajectory_csv

# GDAS ë°ì´í„° ì½ê¸°
gdas_data = read_gdas("gdas1_20260212_00.nc")

# ë‹¤ì¤‘ ì…ì ì´ˆê¸° ìœ„ì¹˜
particles = ParticleSet([(lon0, lat0, z0), (lon1, lat1, z1)])

# ë‚œë¥˜ Ïƒ=1.0, Forward 24ì‹œê°„ ê¶¤ì 
particles.compute_trajectories(forward, steps=24, gdas_data=gdas_data, sigma=1.0)

# CSV ì €ì¥
save_trajectory_csv(particles.paths, "multi_particle_output.csv")

# HYSPLIT CSV ë¹„êµ
h_lons, h_lats, h_zs, h_times = read_hysplit_csv("hysplit_output.csv")
for path in particles.paths:
    py_lons = [p[1] for p in path]
    py_lats = [p[2] for p in path]
    plot_trajectory(h_lons, h_lats, py_lons, py_lats)
```

---

ì´ì œ ì´ **íŒ¨í‚¤ì§€ ì „ì²´ë¥¼ pyhysplit í´ë”**ì— ë„£ê³ , í•„ìš”í•œ íŒ¨í‚¤ì§€ ì„¤ì¹˜ í›„ ë°”ë¡œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤:

```bash
pip install geopy xarray pandas matplotlib
python -m pyhysplit.example
```

---


